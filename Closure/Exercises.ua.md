# Замикання і чейнінг

1. Реалізуйте функцію `seq(...args)` з використанням замикань і чейнінгу,
   яка може викликатися ланцюжком з довільною кількістю функцій, а перший виклик
   зі значенням типу `Number` призведе до виконання переданих раніше функцій і
   повернений результат має бути, як в наведених прикладах:

```js
seq((x) => x + 7)((x) => x * 2)(5);

// Результат: 17
```

```js
seq((x) => x * 2)((x) => x + 7)(5);

// Результат: 24
```

```js
seq((x) => x + 1)((x) => x * 2)((x) => x / 3)((x) => x - 4)(7);

// Результат: 3
```

2. Реалізуйте функцію `array()` яка створює функціональний об'єкт, що містить
   масив у своєму замиканні та забезпечує такий інтерфейс:

- Створення нового екземпляру `const a = array();`
- Отримання елемента за індексом `a(i)`
- Додавання елемента в кінець `a.push(value)`
- Видалення останнього елемента та повернення його значення `a.pop()`

Приклад використання:

```js
const arr = array();

arr.push("first");
arr.push("second");
arr.push("third");

console.log(arr(0)); // Виведе: first
console.log(arr(1)); // Виведе: second
console.log(arr(2)); // Виведе: third

console.log(arr.pop()); // Виведе: third
console.log(arr.pop()); // Виведе: second
console.log(arr.pop()); // Виведе: first

console.log(arr.pop()); // Виведе: undefined
```
